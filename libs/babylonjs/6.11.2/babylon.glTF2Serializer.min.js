!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("babylonjs")):"function"==typeof define&&define.amd?define("babylonjs-serializers",["babylonjs"],t):"object"==typeof exports?exports["babylonjs-serializers"]=t(require("babylonjs")):e.SERIALIZERS=t(e.BABYLON)}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(e=>(()=>{"use strict";var t={520:t=>{t.exports=e}},s={};function r(e){var n=s[e];if(void 0!==n)return n.exports;var i=s[e]={exports:{}};return t[e](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{r.d(n,{default:()=>j});var e={};r.r(e),r.d(e,{__IGLTFExporterExtension:()=>l});var t={};r.r(t),r.d(t,{GLTFData:()=>c});var s={};r.r(s),r.d(s,{GLTF2Export:()=>y});var i={};r.r(i),r.d(i,{EXT_mesh_gpu_instancing:()=>z,KHR_lights_punctual:()=>M,KHR_materials_anisotropy:()=>S,KHR_materials_clearcoat:()=>w,KHR_materials_emissive_strength:()=>H,KHR_materials_ior:()=>L,KHR_materials_iridescence:()=>V,KHR_materials_sheen:()=>v,KHR_materials_specular:()=>U,KHR_materials_transmission:()=>G,KHR_materials_unlit:()=>P,KHR_materials_volume:()=>K,KHR_texture_transform:()=>A});var a={};r.r(a),r.d(a,{EXT_mesh_gpu_instancing:()=>z,GLTF2Export:()=>y,GLTFData:()=>c,KHR_lights_punctual:()=>M,KHR_materials_anisotropy:()=>S,KHR_materials_clearcoat:()=>w,KHR_materials_emissive_strength:()=>H,KHR_materials_ior:()=>L,KHR_materials_iridescence:()=>V,KHR_materials_sheen:()=>v,KHR_materials_specular:()=>U,KHR_materials_transmission:()=>G,KHR_materials_unlit:()=>P,KHR_materials_volume:()=>K,KHR_texture_transform:()=>A,_BinaryWriter:()=>T,_Exporter:()=>x,_GLTFAnimation:()=>d,_GLTFMaterialExporter:()=>f,_GLTFUtilities:()=>p,__IGLTFExporterExtensionV2:()=>$});var o={};r.r(o),r.d(o,{EXT_mesh_gpu_instancing:()=>z,GLTF2Export:()=>y,GLTFData:()=>c,KHR_lights_punctual:()=>M,KHR_materials_anisotropy:()=>S,KHR_materials_clearcoat:()=>w,KHR_materials_emissive_strength:()=>H,KHR_materials_ior:()=>L,KHR_materials_iridescence:()=>V,KHR_materials_sheen:()=>v,KHR_materials_specular:()=>U,KHR_materials_transmission:()=>G,KHR_materials_unlit:()=>P,KHR_materials_volume:()=>K,KHR_texture_transform:()=>A,_BinaryWriter:()=>T,_Exporter:()=>x,_GLTFAnimation:()=>d,_GLTFMaterialExporter:()=>f,_GLTFUtilities:()=>p,__IGLTFExporterExtension:()=>l,__IGLTFExporterExtensionV2:()=>$});var l=0;class c{constructor(){this.glTFFiles={}}downloadFiles(){function e(e,t){return-1!==e.indexOf(t,e.length-t.length)}for(const t in this.glTFFiles){const s=document.createElement("a");document.body.appendChild(s),s.setAttribute("type","hidden"),s.download=t;const r=this.glTFFiles[t];let n;e(t,".glb")?n={type:"model/gltf-binary"}:e(t,".bin")?n={type:"application/octet-stream"}:e(t,".gltf")?n={type:"model/gltf+json"}:e(t,".jpeg")||e(t,".jpg")?n={type:"image/jpeg"}:e(t,".png")&&(n={type:"image/png"}),s.href=window.URL.createObjectURL(new Blob([r],n)),s.click()}}}var u,h=r(520);class f{constructor(e){this._textureMap={},this._internalTextureToImage={},this._textureMap={},this._exporter=e}static _FuzzyEquals(e,t,s){return h.Scalar.WithinEpsilon(e.r,t.r,s)&&h.Scalar.WithinEpsilon(e.g,t.g,s)&&h.Scalar.WithinEpsilon(e.b,t.b,s)}_convertMaterialsToGLTFAsync(e,t,s){const r=[];return e.forEach((e=>{"StandardMaterial"===e.getClassName()?r.push(this._convertStandardMaterialAsync(e,t,s)):-1!==e.getClassName().indexOf("PBR")?r.push(this._convertPBRMaterialAsync(e,t,s)):h.Tools.Warn(`Unsupported material type: ${e.name}`)})),Promise.all(r).then((()=>{}))}_stripTexturesFromMaterial(e){const t={};if(e){t.name=e.name,t.doubleSided=e.doubleSided,t.alphaMode=e.alphaMode,t.alphaCutoff=e.alphaCutoff,t.emissiveFactor=e.emissiveFactor;const s=e.pbrMetallicRoughness;s&&(t.pbrMetallicRoughness={},t.pbrMetallicRoughness.baseColorFactor=s.baseColorFactor,t.pbrMetallicRoughness.metallicFactor=s.metallicFactor,t.pbrMetallicRoughness.roughnessFactor=s.roughnessFactor)}return t}_hasTexturesPresent(e){if(e.emissiveTexture||e.normalTexture||e.occlusionTexture)return!0;const t=e.pbrMetallicRoughness;if(t&&(t.baseColorTexture||t.metallicRoughnessTexture))return!0;if(e.extensions)for(const t in e.extensions){const s=e.extensions[t];if(s)return s.hasTextures?.()}return!1}_getTextureInfo(e){if(e){const t=e.uid;if(t in this._textureMap)return this._textureMap[t]}return null}_convertToGLTFPBRMetallicRoughness(e){const t=new h.Vector2(0,1),s=new h.Vector2(0,.1),r=new h.Vector2(0,.1),n=new h.Vector2(1300,.1),i=e.diffuseColor.toLinearSpace(e.getScene().getEngine().useExactSrgbConversions).scale(.5),a=e.alpha,o=(l=h.Scalar.Clamp(e.specularPower,0,f._MaxSpecularPower),c=Math.pow(l/n.x,.333333),u=t.y,p=s.y,d=r.y,_=n.y,(1-c)*(1-c)*(1-c)*u+3*(1-c)*(1-c)*c*p+3*(1-c)*c*c*d+c*c*c*_);var l,c,u,p,d,_;return{baseColorFactor:[i.r,i.g,i.b,a],metallicFactor:0,roughnessFactor:o}}static _SolveMetallic(e,t,s){if(t<this._DielectricSpecular.r)return this._DielectricSpecular,0;const r=this._DielectricSpecular.r,n=e*s/(1-this._DielectricSpecular.r)+t-2*this._DielectricSpecular.r,i=n*n-4*r*(this._DielectricSpecular.r-t);return h.Scalar.Clamp((-n+Math.sqrt(i))/(2*r),0,1)}static _SetAlphaMode(e,t){t.needAlphaBlending()?e.alphaMode="BLEND":t.needAlphaTesting()&&(e.alphaMode="MASK",e.alphaCutoff=t.alphaCutOff)}_convertStandardMaterialAsync(e,t,s){const r=this._exporter._materialMap,n=this._exporter._materials,i=[],a=this._convertToGLTFPBRMetallicRoughness(e),o={name:e.name};if(null==e.backFaceCulling||e.backFaceCulling||(e.twoSidedLighting||h.Tools.Warn(e.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),o.doubleSided=!0),s){e.diffuseTexture&&i.push(this._exportTextureAsync(e.diffuseTexture,t).then((e=>{e&&(a.baseColorTexture=e)})));const s=e.bumpTexture;s&&i.push(this._exportTextureAsync(s,t).then((e=>{e&&(o.normalTexture=e,1!==s.level&&(o.normalTexture.scale=s.level))}))),e.emissiveTexture&&(o.emissiveFactor=[1,1,1],i.push(this._exportTextureAsync(e.emissiveTexture,t).then((e=>{e&&(o.emissiveTexture=e)})))),e.ambientTexture&&i.push(this._exportTextureAsync(e.ambientTexture,t).then((e=>{if(e){const t={index:e.index};o.occlusionTexture=t}})))}return(e.alpha<1||e.opacityTexture)&&(e.alphaMode===h.Constants.ALPHA_COMBINE?o.alphaMode="BLEND":h.Tools.Warn(e.name+": glTF 2.0 does not support alpha mode: "+e.alphaMode.toString())),e.emissiveColor&&!f._FuzzyEquals(e.emissiveColor,h.Color3.Black(),f._Epsilon)&&(o.emissiveFactor=e.emissiveColor.asArray()),o.pbrMetallicRoughness=a,f._SetAlphaMode(o,e),n.push(o),r[e.uniqueId]=n.length-1,this._finishMaterial(i,o,e,t)}_finishMaterial(e,t,s,r){return Promise.all(e).then((()=>{const e=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",t,s);let n=null;for(const t of e)n||(n=[]),n.push(this._exportTextureAsync(t,r));return n||(n=[Promise.resolve(null)]),Promise.all(n).then((()=>{const e=this._exporter._extensionsPostExportMaterialAsync("exportMaterial",t,s);return e?e.then((()=>t)):t}))}))}async _getImageDataAsync(e,t,s,r){const n=h.Constants.TEXTURETYPE_UNSIGNED_INT,i=this._exporter._babylonScene,a=i.getEngine(),o=a.createRawTexture(e,t,s,h.Constants.TEXTUREFORMAT_RGBA,!1,!0,h.Texture.NEAREST_SAMPLINGMODE,null,n);await h.TextureTools.ApplyPostProcess("pass",o,i,n,h.Constants.TEXTURE_NEAREST_SAMPLINGMODE,h.Constants.TEXTUREFORMAT_RGBA);const l=await a._readTexturePixels(o,t,s);return await h.DumpTools.DumpDataAsync(t,s,l,r,void 0,!0,!0)}_createWhiteTexture(e,t,s){const r=new Uint8Array(e*t*4);for(let e=0;e<r.length;e+=4)r[e]=r[e+1]=r[e+2]=r[e+3]=255;return h.RawTexture.CreateRGBATexture(r,e,t,s)}_resizeTexturesToSameDimensions(e,t,s){const r=e?e.getSize():{width:0,height:0},n=t?t.getSize():{width:0,height:0};let i,a;return r.width<n.width?(i=e&&e instanceof h.Texture?h.TextureTools.CreateResizedCopy(e,n.width,n.height,!0):this._createWhiteTexture(n.width,n.height,s),a=t):r.width>n.width?(a=t&&t instanceof h.Texture?h.TextureTools.CreateResizedCopy(t,r.width,r.height,!0):this._createWhiteTexture(r.width,r.height,s),i=e):(i=e,a=t),{texture1:i,texture2:a}}_convertPixelArrayToFloat32(e){if(e instanceof Uint8Array){const t=e.length,s=new Float32Array(e.length);for(let r=0;r<t;++r)s[r]=e[r]/255;return s}if(e instanceof Float32Array)return e;throw new Error("Unsupported pixel format!")}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(e,t,s,r){const n=new Array;if(!e&&!t)return Promise.reject("_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!");const i=e?e.getScene():t?t.getScene():null;if(i){const a=this._resizeTexturesToSameDimensions(e,t,i),o=a.texture1?.getSize();let l,c;const u=o.width,p=o.height,d=await a.texture1.readPixels(),_=await a.texture2.readPixels();if(!d)return Promise.reject("Failed to retrieve pixels from diffuse texture!");if(l=this._convertPixelArrayToFloat32(d),!_)return Promise.reject("Failed to retrieve pixels from specular glossiness texture!");c=this._convertPixelArrayToFloat32(_);const m=c.byteLength,g=new Uint8Array(m),x=new Uint8Array(m),T=4,y=h.Color3.Black();let b=0,A=0;for(let e=0;e<p;++e)for(let t=0;t<u;++t){const r=(u*e+t)*T,n={diffuseColor:new h.Color3(l[r],l[r+1],l[r+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(s.diffuseColor),specularColor:new h.Color3(c[r],c[r+1],c[r+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(s.specularColor),glossiness:c[r+3]*s.glossiness},o=this._convertSpecularGlossinessToMetallicRoughness(n);y.r=Math.max(y.r,o.baseColor.r),y.g=Math.max(y.g,o.baseColor.g),y.b=Math.max(y.b,o.baseColor.b),b=Math.max(b,o.metallic),A=Math.max(A,o.roughness),x[r]=255*o.baseColor.r,x[r+1]=255*o.baseColor.g,x[r+2]=255*o.baseColor.b,x[r+3]=a.texture1.hasAlpha?255*l[r+3]:255,g[r]=0,g[r+1]=255*o.roughness,g[r+2]=255*o.metallic,g[r+3]=255}const E={baseColor:y,metallic:b,roughness:A};let M=!1,F=!1;for(let e=0;e<p;++e)for(let t=0;t<u;++t){const s=(u*e+t)*T;x[s]/=E.baseColor.r>f._Epsilon?E.baseColor.r:1,x[s+1]/=E.baseColor.g>f._Epsilon?E.baseColor.g:1,x[s+2]/=E.baseColor.b>f._Epsilon?E.baseColor.b:1;const r=h.Color3.FromInts(x[s],x[s+1],x[s+2]).toGammaSpace(i.getEngine().useExactSrgbConversions);x[s]=255*r.r,x[s+1]=255*r.g,x[s+2]=255*r.b,f._FuzzyEquals(r,h.Color3.White(),f._Epsilon)||(F=!0),g[s+1]/=E.roughness>f._Epsilon?E.roughness:1,g[s+2]/=E.metallic>f._Epsilon?E.metallic:1;const n=h.Color3.FromInts(255,g[s+1],g[s+2]);f._FuzzyEquals(n,h.Color3.White(),f._Epsilon)||(M=!0)}return M&&n.push(this._getImageDataAsync(g,u,p,r).then((e=>{E.metallicRoughnessTextureData=e}))),F&&n.push(this._getImageDataAsync(x,u,p,r).then((e=>{E.baseColorTextureData=e}))),Promise.all(n).then((()=>E))}return Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(e){const t=this._getPerceivedBrightness(e.diffuseColor),s=this._getPerceivedBrightness(e.specularColor),r=1-this._getMaxComponent(e.specularColor),n=f._SolveMetallic(t,s,r),i=e.diffuseColor.scale(r/(1-f._DielectricSpecular.r)/Math.max(1-n,f._Epsilon)),a=e.specularColor.subtract(f._DielectricSpecular.scale(1-n)).scale(1/Math.max(n,f._Epsilon));let o=h.Color3.Lerp(i,a,n*n);return o=o.clampToRef(0,1,o),{baseColor:o,metallic:n,roughness:1-e.glossiness}}_getPerceivedBrightness(e){return e?Math.sqrt(.299*e.r*e.r+.587*e.g*e.g+.114*e.b*e.b):0}_getMaxComponent(e){return e?Math.max(e.r,Math.max(e.g,e.b)):0}_convertMetalRoughFactorsToMetallicRoughnessAsync(e,t,s,r){const n=[],i={baseColor:e._albedoColor,metallic:e._metallic,roughness:e._roughness};if(r){e._albedoTexture&&n.push(this._exportTextureAsync(e._albedoTexture,t).then((e=>{e&&(s.baseColorTexture=e)})));const r=e._metallicTexture;r&&n.push(this._exportTextureAsync(r,t).then((e=>{e&&(s.metallicRoughnessTexture=e)})))}return Promise.all(n).then((()=>i))}_getTextureSampler(e){const t={};if(!(e&&e instanceof h.Texture))return t;const s=this._getGLTFTextureWrapMode(e.wrapU);10497!==s&&(t.wrapS=s);const r=this._getGLTFTextureWrapMode(e.wrapV);switch(10497!==r&&(t.wrapT=r),e.samplingMode){case h.Texture.LINEAR_LINEAR:t.magFilter=9729,t.minFilter=9729;break;case h.Texture.LINEAR_NEAREST:t.magFilter=9729,t.minFilter=9728;break;case h.Texture.NEAREST_LINEAR:t.magFilter=9728,t.minFilter=9729;break;case h.Texture.NEAREST_LINEAR_MIPLINEAR:t.magFilter=9728,t.minFilter=9987;break;case h.Texture.NEAREST_NEAREST:t.magFilter=9728,t.minFilter=9728;break;case h.Texture.NEAREST_LINEAR_MIPNEAREST:t.magFilter=9728,t.minFilter=9985;break;case h.Texture.LINEAR_NEAREST_MIPNEAREST:t.magFilter=9729,t.minFilter=9984;break;case h.Texture.LINEAR_NEAREST_MIPLINEAR:t.magFilter=9729,t.minFilter=9986;break;case h.Texture.NEAREST_NEAREST_MIPLINEAR:t.magFilter=9728,t.minFilter=9986;break;case h.Texture.LINEAR_LINEAR_MIPLINEAR:t.magFilter=9729,t.minFilter=9987;break;case h.Texture.LINEAR_LINEAR_MIPNEAREST:t.magFilter=9729,t.minFilter=9985;break;case h.Texture.NEAREST_NEAREST_MIPNEAREST:t.magFilter=9728,t.minFilter=9984}return t}_getGLTFTextureWrapMode(e){switch(e){case h.Texture.WRAP_ADDRESSMODE:return 10497;case h.Texture.CLAMP_ADDRESSMODE:return 33071;case h.Texture.MIRROR_ADDRESSMODE:return 33648;default:return h.Tools.Error(`Unsupported Texture Wrap Mode ${e}!`),10497}}_convertSpecGlossFactorsToMetallicRoughnessAsync(e,t,s,r){return Promise.resolve().then((()=>{const n={diffuseColor:e._albedoColor,specularColor:e._reflectivityColor,glossiness:e._microSurface},i=e._albedoTexture,a=e._reflectivityTexture,o=e._useMicroSurfaceFromReflectivityMapAlpha;if(a&&!o)return Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((i||a)&&r){const e=this._exportTextureSampler(i||a);return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(i,a,n,t).then((r=>{const n=this._exporter._textures;if(r.baseColorTextureData){const a=this._exportImage(`baseColor${n.length}`,t,r.baseColorTextureData);s.baseColorTexture=this._exportTextureInfo(a,e,i?.coordinatesIndex)}if(r.metallicRoughnessTextureData){const i=this._exportImage(`metallicRoughness${n.length}`,t,r.metallicRoughnessTextureData);s.metallicRoughnessTexture=this._exportTextureInfo(i,e,a?.coordinatesIndex)}return r}))}return this._convertSpecularGlossinessToMetallicRoughness(n)}))}_convertPBRMaterialAsync(e,t,s){const r={},n={name:e.name};if(e.isMetallicWorkflow()){const i=e._albedoColor,a=e.alpha;return i&&(r.baseColorFactor=[i.r,i.g,i.b,a]),this._convertMetalRoughFactorsToMetallicRoughnessAsync(e,t,r,s).then((i=>this._setMetallicRoughnessPbrMaterial(i,e,n,r,t,s)))}return this._convertSpecGlossFactorsToMetallicRoughnessAsync(e,t,r,s).then((i=>this._setMetallicRoughnessPbrMaterial(i,e,n,r,t,s)))}_setMetallicRoughnessPbrMaterial(e,t,s,r,n,i){const a=this._exporter._materialMap,o=this._exporter._materials,l=[];if(e){if(f._SetAlphaMode(s,t),f._FuzzyEquals(e.baseColor,h.Color3.White(),f._Epsilon)&&t.alpha>=f._Epsilon||(r.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,t.alpha]),null!=e.metallic&&1!==e.metallic&&(r.metallicFactor=e.metallic),null!=e.roughness&&1!==e.roughness&&(r.roughnessFactor=e.roughness),null==t.backFaceCulling||t.backFaceCulling||(t._twoSidedLighting||h.Tools.Warn(t.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),s.doubleSided=!0),i){const e=t._bumpTexture;if(e){const t=this._exportTextureAsync(e,n).then((t=>{t&&(s.normalTexture=t,1!==e.level&&(s.normalTexture.scale=e.level))}));l.push(t)}const r=t._ambientTexture;if(r){const e=this._exportTextureAsync(r,n).then((e=>{if(e){const r={index:e.index,texCoord:e.texCoord,extensions:e.extensions};s.occlusionTexture=r;const n=t._ambientTextureStrength;n&&(r.strength=n)}}));l.push(e)}const i=t._emissiveTexture;if(i){const e=this._exportTextureAsync(i,n).then((e=>{e&&(s.emissiveTexture=e)}));l.push(e)}}const c=t._emissiveColor;f._FuzzyEquals(c,h.Color3.Black(),f._Epsilon)||(s.emissiveFactor=c.asArray()),s.pbrMetallicRoughness=r,o.push(s),a[t.uniqueId]=o.length-1}return this._finishMaterial(l,s,t,n)}_getPixelsFromTexture(e){return e.textureType,h.Constants.TEXTURETYPE_UNSIGNED_INT,e.readPixels()}_exportTextureAsync(e,t){const s=this._exporter._extensionsPreExportTextureAsync("exporter",e,t);return s?s.then((s=>s?this._exportTextureInfoAsync(s,t):this._exportTextureInfoAsync(e,t))):this._exportTextureInfoAsync(e,t)}async _exportTextureInfoAsync(e,t){const s=e.uid;if(!(s in this._textureMap)){const r=await this._getPixelsFromTexture(e);if(!r)return null;const n=this._exportTextureSampler(e),i=e.mimeType;if(i)switch(i){case"image/jpeg":case"image/png":case"image/webp":t=i;break;default:h.Tools.Warn(`Unsupported media type: ${i}`)}const a=this._internalTextureToImage,o=e.getInternalTexture().uniqueId;a[o]||={};let l=a[o][t];if(void 0===l){const s=e.getSize();l=(async()=>{const n=await this._getImageDataAsync(r,s.width,s.height,t);return this._exportImage(e.name,t,n)})(),a[o][t]=l}const c=this._exportTextureInfo(await l,n,e.coordinatesIndex);this._textureMap[s]=c,this._exporter._extensionsPostExportTextures("exporter",this._textureMap[s],e)}return this._textureMap[s]}_exportImage(e,t,s){const r=this._exporter._imageData,n=e.replace(/\.\/|\/|\.\\|\\/g,"_"),i=function(e){switch(e){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp"}}(t);let a=n+i;a in r&&(a=`${n}_${h.Tools.RandomId()}${i}`),r[a]={data:s,mimeType:t};const o=this._exporter._images;return o.push({name:e,uri:a}),o.length-1}_exportTextureInfo(e,t,s){const r=this._exporter._textures;let n=r.findIndex((s=>s.sampler==t&&s.source===e));-1===n&&(n=r.length,r.push({source:e,sampler:t}));const i={index:n};return s&&(i.texCoord=s),i}_exportTextureSampler(e){const t=this._getTextureSampler(e),s=this._exporter._samplers,r=s.findIndex((e=>e.minFilter===t.minFilter&&e.magFilter===t.magFilter&&e.wrapS===t.wrapS&&e.wrapT===t.wrapT));return-1!==r?r:(s.push(t),s.length-1)}}f._DielectricSpecular=new h.Color3(.04,.04,.04),f._MaxSpecularPower=1024,f._Epsilon=1e-6;class p{static _CreateBufferView(e,t,s,r,n){const i={buffer:e,byteLength:s};return t&&(i.byteOffset=t),n&&(i.name=n),r&&(i.byteStride=r),i}static _CreateAccessor(e,t,s,r,n,i,a,o){const l={name:t,bufferView:e,componentType:r,count:n,type:s};return null!=a&&(l.min=a),null!=o&&(l.max=o),null!=i&&(l.byteOffset=i),l}static _CalculateMinMaxPositions(e,t,s){const r=[1/0,1/0,1/0],n=[-1/0,-1/0,-1/0];let i,a,o;if(s)for(let l=t,c=t+s;l<c;++l){i=3*l,a=h.Vector3.FromArray(e,i),o=a.asArray();for(let e=0;e<3;++e){const t=o[e];t<r[e]&&(r[e]=t),t>n[e]&&(n[e]=t),++i}}return{min:r,max:n}}static _NormalizeTangentFromRef(e){const t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);t>0&&(e.x/=t,e.y/=t,e.z/=t)}static _GetDataAccessorElementCount(e){switch(e){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}}!function(e){e[e.INTANGENT=0]="INTANGENT",e[e.OUTTANGENT=1]="OUTTANGENT"}(u||(u={}));class d{static _IsTransformable(e){return e&&(e instanceof h.TransformNode||e instanceof h.Camera||e instanceof h.Light)}static _CreateNodeAnimation(e,t,s,r,n){if(this._IsTransformable(e)){const i=[],a=[],o=t.getKeys(),l=d._CalculateMinMaxKeyFrames(o),c=d._DeduceInterpolation(o,s,r),u=c.interpolationType,f=c.shouldBakeAnimation;if(f?d._CreateBakedAnimation(e,t,s,l.min,l.max,t.framePerSecond,n,i,a,l,r):"LINEAR"===u||"STEP"===u?d._CreateLinearOrStepAnimation(e,t,s,i,a,r):"CUBICSPLINE"===u?d._CreateCubicSplineAnimation(e,t,s,i,a,r):d._CreateBakedAnimation(e,t,s,l.min,l.max,t.framePerSecond,n,i,a,l,r),i.length&&a.length)return{inputs:i,outputs:a,samplerInterpolation:u,inputsMin:f?l.min:h.Tools.FloatRound(l.min/t.framePerSecond),inputsMax:f?l.max:h.Tools.FloatRound(l.max/t.framePerSecond)}}return null}static _DeduceAnimationInfo(e){let t=null,s="VEC3",r=!1;const n=e.targetProperty.split(".");switch(n[0]){case"scaling":t="scale";break;case"position":t="translation";break;case"rotation":s="VEC4",t="rotation";break;case"rotationQuaternion":s="VEC4",r=!0,t="rotation";break;case"influence":s="SCALAR",t="weights";break;default:h.Tools.Error(`Unsupported animatable property ${n[0]}`)}return t?{animationChannelTargetPath:t,dataAccessorType:s,useQuaternion:r}:(h.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(e,t,s,r,n,i,a,o,l,c){let u;if(d._IsTransformable(e)&&e.animations)for(const n of e.animations){if(c&&!c(n))continue;const h=d._DeduceAnimationInfo(n);h&&(u={name:n.name,samplers:[],channels:[]},d._AddAnimation(`${n.name}`,n.hasRunningRuntimeAnimations?t:u,e,n,h.dataAccessorType,h.animationChannelTargetPath,r,i,a,o,h.useQuaternion,l),u.samplers.length&&u.channels.length&&s.push(u))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(e,t,s,r,n,i,a,o,l,c){let u;if(e instanceof h.Mesh){const n=e.morphTargetManager;if(n)for(let f=0;f<n.numTargets;++f){const p=n.getTarget(f);for(const _ of p.animations){if(c&&!c(_))continue;const p=new h.Animation(`${_.name}`,"influence",_.framePerSecond,_.dataType,_.loopMode,_.enableBlending),m=[],g=_.getKeys();for(let e=0;e<g.length;++e){const t=g[e];for(let e=0;e<n.numTargets;++e)e==f?m.push(t):m.push({frame:t.frame,value:0})}p.setKeys(m);const x=d._DeduceAnimationInfo(p);x&&(u={name:p.name,samplers:[],channels:[]},d._AddAnimation(_.name,_.hasRunningRuntimeAnimations?t:u,e,p,x.dataAccessorType,x.animationChannelTargetPath,r,i,a,o,x.useQuaternion,l,n.numTargets),u.samplers.length&&u.channels.length&&s.push(u))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(e,t,s,r,n,i,a,o){let l;if(e.animationGroups){const c=e.animationGroups;for(const u of c){const c=new Map,f=new Map,p=new Set,_=u.to-u.from;l={name:u.name,channels:[],samplers:[]};for(let t=0;t<u.targetedAnimations.length;++t){const _=u.targetedAnimations[t],m=_.target,g=_.animation;if(!o||o(g))if(this._IsTransformable(m)||1===m.length&&this._IsTransformable(m[0])){const e=d._DeduceAnimationInfo(_.animation);if(e){const t=this._IsTransformable(m)?m:this._IsTransformable(m[0])?m[0]:null;t&&d._AddAnimation(`${g.name}`,l,t,g,e.dataAccessorType,e.animationChannelTargetPath,s,r,n,i,e.useQuaternion,a)}}else if((m instanceof h.MorphTarget||1===m.length&&m[0]instanceof h.MorphTarget)&&d._DeduceAnimationInfo(_.animation)){const t=m instanceof h.MorphTarget?m:m[0];if(t){const s=e.morphTargetManagers.find((e=>{for(let s=0;s<e.numTargets;++s)if(e.getTarget(s)===t)return!0;return!1}));if(s){const r=e.meshes.find((e=>e.morphTargetManager===s));r&&(c.has(r)||c.set(r,new Map),c.get(r)?.set(t,g),p.add(r),f.set(r,g))}}}}p.forEach((e=>{const t=e.morphTargetManager;let o=null;const p=[],m=f.get(e).getKeys(),g=m.length;for(let s=0;s<g;++s)for(let r=0;r<t.numTargets;++r){const n=t.getTarget(r),i=c.get(e);if(i){const t=i.get(n);t?(o||(o=new h.Animation(`${u.name}_${e.name}_MorphWeightAnimation`,"influence",t.framePerSecond,h.Animation.ANIMATIONTYPE_FLOAT,t.loopMode,t.enableBlending)),p.push(t.getKeys()[s])):p.push({frame:u.from+_/g*s,value:n.influence,inTangent:m[0].inTangent?0:void 0,outTangent:m[0].outTangent?0:void 0})}}o.setKeys(p);const x=d._DeduceAnimationInfo(o);x&&d._AddAnimation(`${u.name}_${e.name}_MorphWeightAnimation`,l,e,o,x.dataAccessorType,x.animationChannelTargetPath,s,r,n,i,x.useQuaternion,a,t?.numTargets)})),l.channels.length&&l.samplers.length&&t.push(l)}}}static _AddAnimation(e,t,s,r,n,i,a,o,l,c,u,h,f){const _=d._CreateNodeAnimation(s,r,i,u,h);let m,g,x,T,y,b,A;if(_){if(f){let e=0,t=0;const s=[];for(;_.inputs.length>0;)t=_.inputs.shift(),e%f==0&&s.push(t),e++;_.inputs=s}const r=a[s.uniqueId];let u=4*_.inputs.length;m=p._CreateBufferView(0,o.getByteOffset(),u,void 0,`${e}  keyframe data view`),l.push(m),_.inputs.forEach((function(e){o.setFloat32(e)})),g=p._CreateAccessor(l.length-1,`${e}  keyframes`,"SCALAR",5126,_.inputs.length,null,[_.inputsMin],[_.inputsMax]),c.push(g),x=c.length-1,y=_.outputs.length,u=4*p._GetDataAccessorElementCount(n)*_.outputs.length,m=p._CreateBufferView(0,o.getByteOffset(),u,void 0,`${e}  data view`),l.push(m),_.outputs.forEach((function(e){e.forEach((function(e){o.setFloat32(e)}))})),g=p._CreateAccessor(l.length-1,`${e}  data`,n,5126,y,null,null,null),c.push(g),T=c.length-1,b={interpolation:_.samplerInterpolation,input:x,output:T},t.samplers.push(b),A={sampler:t.samplers.length-1,target:{node:r,path:i}},t.channels.push(A)}}static _CreateBakedAnimation(e,t,s,r,n,i,a,o,l,c,u){let f;const p=h.Quaternion.Identity();let _,m=null,g=null,x=null,T=null,y=null,b=null;c.min=h.Tools.FloatRound(r/i);const A=t.getKeys();for(let r=0,c=A.length;r<c;++r){if(b=null,x=A[r],r+1<c)if(T=A[r+1],x.value.equals&&x.value.equals(T.value)||x.value===T.value){if(0!==r)continue;b=x.frame}else b=T.frame;else{if(y=A[r-1],x.value.equals&&x.value.equals(y.value)||x.value===y.value)continue;b=n}if(b)for(let r=x.frame;r<=b;r+=a){if(_=h.Tools.FloatRound(r/i),_===m)continue;m=_,g=_;const n={key:0,repeatCount:0,loopMode:t.loopMode};f=t._interpolate(r,n),d._SetInterpolatedValue(e,f,_,t,s,p,o,l,u)}}g&&(c.max=g)}static _ConvertFactorToVector3OrQuaternion(e,t,s,r,n){const i=d._GetBasePositionRotationOrScale(t,r,n),a=s.targetProperty.split("."),o=a?a[1]:"",l=n?h.Quaternion.FromArray(i).normalize():h.Vector3.FromArray(i);switch(o){case"x":case"y":case"z":l[o]=e;break;case"w":l.w=e;break;default:h.Tools.Error(`glTFAnimation: Unsupported component name "${o}"!`)}return l}static _SetInterpolatedValue(e,t,s,r,n,i,a,o,l){let c;a.push(s),"weights"!==n?(r.dataType===h.Animation.ANIMATIONTYPE_FLOAT&&(t=this._ConvertFactorToVector3OrQuaternion(t,e,r,n,l)),"rotation"===n?(l?i=t:(c=t,h.Quaternion.RotationYawPitchRollToRef(c.y,c.x,c.z,i)),o.push(i.asArray())):(c=t,o.push(c.asArray()))):o.push([t])}static _CreateLinearOrStepAnimation(e,t,s,r,n,i){for(const a of t.getKeys())r.push(a.frame/t.framePerSecond),d._AddKeyframeValue(a,t,n,s,e,i)}static _CreateCubicSplineAnimation(e,t,s,r,n,i){t.getKeys().forEach((function(a){r.push(a.frame/t.framePerSecond),d._AddSplineTangent(u.INTANGENT,n,s,"CUBICSPLINE",a,i),d._AddKeyframeValue(a,t,n,s,e,i),d._AddSplineTangent(u.OUTTANGENT,n,s,"CUBICSPLINE",a,i)}))}static _GetBasePositionRotationOrScale(e,t,s){let r;return r="rotation"===t?s?(e.rotationQuaternion??h.Quaternion.Identity()).asArray():(e.rotation??h.Vector3.Zero()).asArray():"translation"===t?(e.position??h.Vector3.Zero()).asArray():(e.scaling??h.Vector3.One()).asArray(),r}static _AddKeyframeValue(e,t,s,r,n,i){let a;const o=t.dataType;if(o===h.Animation.ANIMATIONTYPE_VECTOR3){let t=e.value.asArray();if("rotation"===r){const e=h.Vector3.FromArray(t);t=h.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).asArray()}s.push(t)}else if(o===h.Animation.ANIMATIONTYPE_FLOAT){if("weights"===r)s.push([e.value]);else if(a=this._ConvertFactorToVector3OrQuaternion(e.value,n,t,r,i),a){if("rotation"===r){const e=i?a:h.Quaternion.RotationYawPitchRoll(a.y,a.x,a.z).normalize();s.push(e.asArray())}s.push(a.asArray())}}else o===h.Animation.ANIMATIONTYPE_QUATERNION?s.push(e.value.normalize().asArray()):h.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(e,t,s){let r,n,i=!1;if("rotation"===t&&!s)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let t=0,s=e.length;t<s;++t)if(n=e[t],n.inTangent||n.outTangent)if(r){if("CUBICSPLINE"!==r){r="LINEAR",i=!0;break}}else r="CUBICSPLINE";else if(r){if("CUBICSPLINE"===r||n.interpolation&&n.interpolation===h.AnimationKeyInterpolation.STEP&&"STEP"!==r){r="LINEAR",i=!0;break}}else r=n.interpolation&&n.interpolation===h.AnimationKeyInterpolation.STEP?"STEP":"LINEAR";return r||(r="LINEAR"),{interpolationType:r,shouldBakeAnimation:i}}static _AddSplineTangent(e,t,s,r,n,i){let a;const o=e===u.INTANGENT?n.inTangent:n.outTangent;if("CUBICSPLINE"===r){if("rotation"===s)if(o)if(i)a=o.asArray();else{const e=o;a=h.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).asArray()}else a=[0,0,0,0];else a="weights"===s?o?[o]:[0]:o?o.asArray():[0,0,0];t.push(a)}}static _CalculateMinMaxKeyFrames(e){let t=1/0,s=-1/0;return e.forEach((function(e){t=Math.min(t,e.frame),s=Math.max(s,e.frame)})),{min:t,max:s}}}const _=h.Matrix.Compose(new h.Vector3(-1,1,1),h.Quaternion.Identity(),h.Vector3.Zero());function m(e,t){if(!(e instanceof h.TransformNode))return!1;if(t){if(!e.getWorldMatrix().isIdentity())return!1}else if(!e.getWorldMatrix().multiplyToRef(_,h.TmpVectors.Matrix[0]).isIdentity())return!1;return!(e instanceof h.Mesh&&e.geometry||e instanceof h.InstancedMesh&&e.sourceMesh.geometry)}function g(e){const t=h.Vector3.FromArrayToRef(e.translation||[0,0,0],0,h.TmpVectors.Vector3[0]),s=h.Quaternion.FromArrayToRef(e.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[0]),r=h.Vector3.FromArrayToRef(e.scale||[1,1,1],0,h.TmpVectors.Vector3[1]);h.Matrix.ComposeToRef(r,s,t,h.TmpVectors.Matrix[0]).multiplyToRef(_,h.TmpVectors.Matrix[0]).decompose(r,s,t),t.equalsToFloats(0,0,0)?delete e.translation:e.translation=t.asArray(),h.Quaternion.IsIdentity(s)?delete e.rotation:e.rotation=s.asArray(),r.equalsToFloats(1,1,1)?delete e.scale:e.scale=r.asArray()}class x{_applyExtension(e,t,s,r){if(s>=t.length)return Promise.resolve(e);const n=r(t[s],e);return n?n.then((e=>this._applyExtension(e,t,s+1,r))):this._applyExtension(e,t,s+1,r)}_applyExtensions(e,t){const s=[];for(const e of x._ExtensionNames)s.push(this._extensions[e]);return this._applyExtension(e,s,0,t)}_extensionsPreExportTextureAsync(e,t,s){return this._applyExtensions(t,((t,r)=>t.preExportTextureAsync&&t.preExportTextureAsync(e,r,s)))}_extensionsPostExportMeshPrimitiveAsync(e,t,s,r){return this._applyExtensions(t,((t,n)=>t.postExportMeshPrimitiveAsync&&t.postExportMeshPrimitiveAsync(e,n,s,r)))}_extensionsPostExportNodeAsync(e,t,s,r,n){return this._applyExtensions(t,((t,i)=>t.postExportNodeAsync&&t.postExportNodeAsync(e,i,s,r,n)))}_extensionsPostExportMaterialAsync(e,t,s){return this._applyExtensions(t,((t,r)=>t.postExportMaterialAsync&&t.postExportMaterialAsync(e,r,s)))}_extensionsPostExportMaterialAdditionalTextures(e,t,s){const r=[];for(const n of x._ExtensionNames){const i=this._extensions[n];i.postExportMaterialAdditionalTextures&&r.push(...i.postExportMaterialAdditionalTextures(e,t,s))}return r}_extensionsPostExportTextures(e,t,s){for(const r of x._ExtensionNames){const n=this._extensions[r];n.postExportTexture&&n.postExportTexture(e,t,s)}}_forEachExtensions(e){for(const t of x._ExtensionNames){const s=this._extensions[t];s.enabled&&e(s)}}_extensionsOnExporting(){this._forEachExtensions((e=>{e.wasUsed&&(null==this._glTF.extensionsUsed&&(this._glTF.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(e.name)&&this._glTF.extensionsUsed.push(e.name),e.required&&(null==this._glTF.extensionsRequired&&(this._glTF.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(e.name)&&this._glTF.extensionsRequired.push(e.name)),null==this._glTF.extensions&&(this._glTF.extensions={}),e.onExporting&&e.onExporting())}))}_loadExtensions(){for(const e of x._ExtensionNames){const t=x._ExtensionFactories[e](this);this._extensions[e]=t}}constructor(e,t){this._extensions={},this._glTF={asset:{generator:`Babylon.js v${h.Engine.Version}`,version:"2.0"}},(e=e||h.EngineStore.LastCreatedScene)&&(this._babylonScene=e,this._bufferViews=[],this._accessors=[],this._meshes=[],this._scenes=[],this._cameras=[],this._nodes=[],this._images=[],this._materials=[],this._materialMap=[],this._textures=[],this._samplers=[],this._skins=[],this._animations=[],this._imageData={},this._orderedImageData=[],this._options=t||{},this._animationSampleRate=this._options.animationSampleRate||1/60,this._glTFMaterialExporter=new f(this),this._loadExtensions())}dispose(){for(const e in this._extensions)this._extensions[e].dispose()}get options(){return this._options}static RegisterExtension(e,t){x.UnregisterExtension(e)&&h.Tools.Warn(`Extension with the name ${e} already exists`),x._ExtensionFactories[e]=t,x._ExtensionNames.push(e)}static UnregisterExtension(e){if(!x._ExtensionFactories[e])return!1;delete x._ExtensionFactories[e];const t=x._ExtensionNames.indexOf(e);return-1!==t&&x._ExtensionNames.splice(t,1),!0}_reorderIndicesBasedOnPrimitiveMode(e,t,s,r,n){switch(t){case h.Material.TriangleFillMode:r||(r=0);for(let t=e.indexStart,s=e.indexStart+e.indexCount;t<s;t+=3){const e=r+4*t,s=n.getUInt32(e+4),i=n.getUInt32(e+8);n.setUInt32(i,e+4),n.setUInt32(s,e+8)}break;case h.Material.TriangleFanDrawMode:for(let t=e.indexStart+e.indexCount-1,i=e.indexStart;t>=i;--t)n.setUInt32(s[t],r),r+=4;break;case h.Material.TriangleStripDrawMode:e.indexCount>=3&&(n.setUInt32(s[e.indexStart+2],r+4),n.setUInt32(s[e.indexStart+1],r+8))}}_reorderVertexAttributeDataBasedOnPrimitiveMode(e,t,s,r,n,i){switch(t){case h.Material.TriangleFillMode:this._reorderTriangleFillMode(e,s,r,n,i);break;case h.Material.TriangleStripDrawMode:this._reorderTriangleStripDrawMode(e,s,r,n,i);break;case h.Material.TriangleFanDrawMode:this._reorderTriangleFanMode(e,s,r,n,i)}}_reorderTriangleFillMode(e,t,s,r,n){const i=this._getVertexBufferFromMesh(t,e.getMesh());if(i){const a=i.byteStride/h.VertexBuffer.GetTypeByteLength(i.type);if(e.verticesCount%3!=0)h.Tools.Error("The submesh vertices for the triangle fill mode is not divisible by 3!");else{const o=[];let l=0;switch(t){case h.VertexBuffer.PositionKind:case h.VertexBuffer.NormalKind:for(let t=e.verticesStart;t<e.verticesStart+e.verticesCount;t+=3)l=t*a,o.push(h.Vector3.FromArray(s,l)),o.push(h.Vector3.FromArray(s,l+2*a)),o.push(h.Vector3.FromArray(s,l+a));break;case h.VertexBuffer.TangentKind:for(let t=e.verticesStart;t<e.verticesStart+e.verticesCount;t+=3)l=t*a,o.push(h.Vector4.FromArray(s,l)),o.push(h.Vector4.FromArray(s,l+2*a)),o.push(h.Vector4.FromArray(s,l+a));break;case h.VertexBuffer.ColorKind:{const t=i.getSize();for(let r=e.verticesStart;r<e.verticesStart+e.verticesCount;r+=t)l=r*a,4===t?(o.push(h.Vector4.FromArray(s,l)),o.push(h.Vector4.FromArray(s,l+2*a)),o.push(h.Vector4.FromArray(s,l+a))):(o.push(h.Vector3.FromArray(s,l)),o.push(h.Vector3.FromArray(s,l+2*a)),o.push(h.Vector3.FromArray(s,l+a)));break}case h.VertexBuffer.UVKind:case h.VertexBuffer.UV2Kind:for(let t=e.verticesStart;t<e.verticesStart+e.verticesCount;t+=3)l=t*a,o.push(h.Vector2.FromArray(s,l)),o.push(h.Vector2.FromArray(s,l+2*a)),o.push(h.Vector2.FromArray(s,l+a));break;default:h.Tools.Error(`Unsupported Vertex Buffer type: ${t}`)}this._writeVertexAttributeData(o,r,t,n)}}else h.Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${t} not present!`)}_reorderTriangleStripDrawMode(e,t,s,r,n){const i=this._getVertexBufferFromMesh(t,e.getMesh());if(i){const a=i.byteStride/h.VertexBuffer.GetTypeByteLength(i.type),o=[];let l=0;switch(t){case h.VertexBuffer.PositionKind:case h.VertexBuffer.NormalKind:l=e.verticesStart,o.push(h.Vector3.FromArray(s,l+2*a)),o.push(h.Vector3.FromArray(s,l+a));break;case h.VertexBuffer.TangentKind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,o.push(h.Vector4.FromArray(s,l));break;case h.VertexBuffer.ColorKind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,4===i.getSize()?o.push(h.Vector4.FromArray(s,l)):o.push(h.Vector3.FromArray(s,l));break;case h.VertexBuffer.UVKind:case h.VertexBuffer.UV2Kind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,o.push(h.Vector2.FromArray(s,l));break;default:h.Tools.Error(`Unsupported Vertex Buffer type: ${t}`)}this._writeVertexAttributeData(o,r+12,t,n)}else h.Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${t} not present!`)}_reorderTriangleFanMode(e,t,s,r,n){const i=this._getVertexBufferFromMesh(t,e.getMesh());if(i){const a=i.byteStride/h.VertexBuffer.GetTypeByteLength(i.type),o=[];let l=0;switch(t){case h.VertexBuffer.PositionKind:case h.VertexBuffer.NormalKind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,o.push(h.Vector3.FromArray(s,l));break;case h.VertexBuffer.TangentKind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,o.push(h.Vector4.FromArray(s,l));break;case h.VertexBuffer.ColorKind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,o.push(h.Vector4.FromArray(s,l)),4===i.getSize()?o.push(h.Vector4.FromArray(s,l)):o.push(h.Vector3.FromArray(s,l));break;case h.VertexBuffer.UVKind:case h.VertexBuffer.UV2Kind:for(let t=e.verticesStart+e.verticesCount-1;t>=e.verticesStart;--t)l=t*a,o.push(h.Vector2.FromArray(s,l));break;default:h.Tools.Error(`Unsupported Vertex Buffer type: ${t}`)}this._writeVertexAttributeData(o,r,t,n)}else h.Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${t} not present!`)}_writeVertexAttributeData(e,t,s,r){for(const n of e){s===h.VertexBuffer.NormalKind?n.normalize():s===h.VertexBuffer.TangentKind&&n instanceof h.Vector4&&p._NormalizeTangentFromRef(n);for(const e of n.asArray())r.setFloat32(e,t),t+=4}}_writeAttributeData(e,t,s,r,n,i){let a,o,l=[];switch(e){case h.VertexBuffer.PositionKind:for(let e=0,t=s.length/r;e<t;++e){a=e*r;const t=h.Vector3.FromArray(s,a);l.push(t.asArray())}break;case h.VertexBuffer.NormalKind:for(let e=0,t=s.length/r;e<t;++e){a=e*r;const t=h.Vector3.FromArray(s,a);l.push(t.normalize().asArray())}break;case h.VertexBuffer.TangentKind:for(let e=0,t=s.length/r;e<t;++e){a=e*r;const t=h.Vector4.FromArray(s,a);p._NormalizeTangentFromRef(t),l.push(t.asArray())}break;case h.VertexBuffer.ColorKind:{const e=i.material,t=!e||"StandardMaterial"===e.getClassName(),n=3===r?new h.Color3:new h.Color4,o=this._babylonScene.getEngine().useExactSrgbConversions;for(let e=0,i=s.length/r;e<i;++e)a=e*r,3===r?(h.Color3.FromArrayToRef(s,a,n),t&&n.toLinearSpaceToRef(n,o)):(h.Color4.FromArrayToRef(s,a,n),t&&n.toLinearSpaceToRef(n,o)),l.push(n.asArray());break}case h.VertexBuffer.UVKind:case h.VertexBuffer.UV2Kind:for(let e=0,t=s.length/r;e<t;++e){a=e*r;const t=h.Vector2.FromArray(s,a);l.push(t.asArray())}break;case h.VertexBuffer.MatricesIndicesKind:case h.VertexBuffer.MatricesIndicesExtraKind:for(let e=0,t=s.length/r;e<t;++e){a=e*r;const t=h.Vector4.FromArray(s,a);l.push(t.asArray())}break;case h.VertexBuffer.MatricesWeightsKind:case h.VertexBuffer.MatricesWeightsExtraKind:for(let e=0,t=s.length/r;e<t;++e){a=e*r;const t=h.Vector4.FromArray(s,a);l.push(t.asArray())}break;default:h.Tools.Warn("Unsupported Vertex Buffer Type: "+e),l=[]}switch(t){case 5121:o=n.setUInt8.bind(n);break;case 5123:o=n.setUInt16.bind(n);break;case 5125:o=n.setUInt32.bind(n);break;case 5126:o=n.setFloat32.bind(n);break;default:return void h.Tools.Warn("Unsupported Attribute Component kind: "+t)}for(const e of l)for(const t of e)o(t)}writeMorphTargetAttributeData(e,t,s,r,n,i,a,o){let l,c,u=[],f=new h.Vector3,d=new h.Vector4(0,0,0,0);switch(e){case h.VertexBuffer.PositionKind:for(let e=s.verticesStart;e<s.verticesCount;++e){l=s.indexStart+e*i;const t=h.Vector3.FromArray(r,l);f=h.Vector3.FromArray(n,l).subtractToRef(t,f),o&&(o.min.copyFromFloats(Math.min(f.x,o.min.x),Math.min(f.y,o.min.y),Math.min(f.z,o.min.z)),o.max.copyFromFloats(Math.max(f.x,o.max.x),Math.max(f.y,o.max.y),Math.max(f.z,o.max.z))),u.push(f.asArray())}break;case h.VertexBuffer.NormalKind:for(let e=s.verticesStart;e<s.verticesCount;++e){l=s.indexStart+e*i;const t=h.Vector3.FromArray(r,l).normalize();f=h.Vector3.FromArray(n,l).normalize().subtractToRef(t,f),u.push(f.asArray())}break;case h.VertexBuffer.TangentKind:for(let e=s.verticesStart;e<s.verticesCount;++e){l=s.indexStart+e*(i+1);const t=h.Vector4.FromArray(r,l);p._NormalizeTangentFromRef(t);const a=h.Vector4.FromArray(n,l);p._NormalizeTangentFromRef(a),d=a.subtractToRef(t,d),u.push([d.x,d.y,d.z])}break;default:h.Tools.Warn("Unsupported Vertex Buffer Type: "+e),u=[]}switch(t){case 5121:c=a.setUInt8.bind(a);break;case 5123:c=a.setUInt16.bind(a);break;case 5125:c=a.setUInt32.bind(a);break;case 5126:c=a.setFloat32.bind(a);break;default:return void h.Tools.Warn("Unsupported Attribute Component kind: "+t)}for(const e of u)for(const t of e)c(t)}_generateJSON(e,t,s){const r={byteLength:this._totalByteLength};let n,i,a,o=this._totalByteLength;return r.byteLength&&(this._glTF.buffers=[r]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.scene=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(e?(this._glTF.images=[],this._images.forEach((e=>{e.uri&&(i=this._imageData[e.uri],this._orderedImageData.push(i),n=e.uri.split(".")[0]+" image",a=p._CreateBufferView(0,o,i.data.byteLength,void 0,n),o+=i.data.byteLength,this._bufferViews.push(a),e.bufferView=this._bufferViews.length-1,e.name=n,e.mimeType=i.mimeType,e.uri=void 0,this._glTF.images||(this._glTF.images=[]),this._glTF.images.push(e))})),r.byteLength=o):this._glTF.images=this._images),e||(r.uri=t+".bin"),s?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}_generateGLTFAsync(e,t=!0){return this._generateBinaryAsync().then((s=>{this._extensionsOnExporting();const r=this._generateJSON(!1,e,!0),n=new Blob([s],{type:"application/octet-stream"}),i=e+".gltf",a=e+".bin",o=new c;if(o.glTFFiles[i]=r,o.glTFFiles[a]=n,this._imageData)for(const e in this._imageData)o.glTFFiles[e]=new Blob([this._imageData[e].data],{type:this._imageData[e].mimeType});return t&&this.dispose(),o}))}_generateBinaryAsync(){const e=new T(4);return this._createSceneAsync(e).then((()=>(this._localEngine&&this._localEngine.dispose(),e.getArrayBuffer())))}_getPadding(e){const t=e%4;return 0===t?t:4-t}_generateGLBAsync(e,t=!0){return this._generateBinaryAsync().then((s=>{this._extensionsOnExporting();const r=this._generateJSON(!0),n=e+".glb";let i,a=r.length,o=0;"undefined"!=typeof TextEncoder&&(i=(new TextEncoder).encode(r),a=i.length);for(let e=0;e<this._orderedImageData.length;++e)o+=this._orderedImageData[e].data.byteLength;const l=this._getPadding(a),u=this._getPadding(s.byteLength),h=this._getPadding(o),f=28+a+l+s.byteLength+u+o+h,p=new ArrayBuffer(12),d=new DataView(p);d.setUint32(0,1179937895,!0),d.setUint32(4,2,!0),d.setUint32(8,f,!0);const _=new ArrayBuffer(8+a+l),m=new DataView(_);m.setUint32(0,a+l,!0),m.setUint32(4,1313821514,!0);const g=new Uint8Array(_,8);if(i)g.set(i);else{const e="_".charCodeAt(0);for(let t=0;t<a;++t){const s=r.charCodeAt(t);s!=r.codePointAt(t)?g[t]=e:g[t]=s}}const x=new Uint8Array(_,8+a);for(let e=0;e<l;++e)x[e]=32;const T=new ArrayBuffer(8),y=new DataView(T);y.setUint32(0,s.byteLength+o+h,!0),y.setUint32(4,5130562,!0);const b=new ArrayBuffer(u),A=new Uint8Array(b);for(let e=0;e<u;++e)A[e]=0;const E=new ArrayBuffer(h),M=new Uint8Array(E);for(let e=0;e<h;++e)M[e]=0;const F=[p,_,T,s];for(let e=0;e<this._orderedImageData.length;++e)F.push(this._orderedImageData[e].data);F.push(b),F.push(E);const w=new Blob(F,{type:"application/octet-stream"}),C=new c;return C.glTFFiles[n]=w,null!=this._localEngine&&this._localEngine.dispose(),t&&this.dispose(),C}))}_setNodeTransformation(e,t){t.getPivotPoint().equalsToFloats(0,0,0)||h.Tools.Warn("Pivot points are not supported in the glTF serializer"),t.position.equalsToFloats(0,0,0)||(e.translation=t.position.asArray()),t.scaling.equalsToFloats(1,1,1)||(e.scale=t.scaling.asArray());const s=h.Quaternion.RotationYawPitchRoll(t.rotation.y,t.rotation.x,t.rotation.z);t.rotationQuaternion&&s.multiplyInPlace(t.rotationQuaternion),h.Quaternion.IsIdentity(s)||(e.rotation=s.normalize().asArray())}_setCameraTransformation(e,t){t.position.equalsToFloats(0,0,0)||(e.translation=t.position.asArray());const s=t.rotationQuaternion;s&&!h.Quaternion.IsIdentity(s)&&(e.rotation=s.normalize().asArray())}_getVertexBufferFromMesh(e,t){if(t.isVerticesDataPresent(e,!0)){const s=t.getVertexBuffer(e,!0);if(s)return s}return null}_createBufferViewKind(e,t,s,r,n){const i=s instanceof h.Mesh?s:s instanceof h.InstancedMesh?s.sourceMesh:null;if(i){const a=i.getVertexBuffer(e,!0),o=i.getVerticesData(e,void 0,void 0,!0);if(a&&o){const a=h.VertexBuffer.GetTypeByteLength(t),l=o.length*a,c=p._CreateBufferView(0,r.getByteOffset(),l,n,e+" - "+i.name);this._bufferViews.push(c),this._writeAttributeData(e,t,o,n/a,r,s)}}}_setMorphTargetAttributes(e,t,s,r){if(s){t.targets||(t.targets=[]);const n={},i=e.getMesh();if(s.hasNormals){const t=i.getVerticesData(h.VertexBuffer.NormalKind,void 0,void 0,!0),a=s.getNormals(),o=e.verticesCount,l=12,c=o*l,u=p._CreateBufferView(0,r.getByteOffset(),c,l,s.name+"_NORMAL");this._bufferViews.push(u);const f=this._bufferViews.length-1,d=p._CreateAccessor(f,s.name+" - NORMAL","VEC3",5126,o,0,null,null);this._accessors.push(d),n.NORMAL=this._accessors.length-1,this.writeMorphTargetAttributeData(h.VertexBuffer.NormalKind,5126,e,t,a,l/4,r)}if(s.hasPositions){const t=i.getVerticesData(h.VertexBuffer.PositionKind,void 0,void 0,!0),a=s.getPositions(),o=e.verticesCount,l=12,c=o*l,u=p._CreateBufferView(0,r.getByteOffset(),c,l,s.name+"_POSITION");this._bufferViews.push(u);const f=this._bufferViews.length-1,d={min:new h.Vector3(1/0,1/0,1/0),max:new h.Vector3(-1/0,-1/0,-1/0)},_=p._CreateAccessor(f,s.name+" - POSITION","VEC3",5126,o,0,null,null);this._accessors.push(_),n.POSITION=this._accessors.length-1,this.writeMorphTargetAttributeData(h.VertexBuffer.PositionKind,5126,e,t,a,l/4,r,d),_.min=d.min.asArray(),_.max=d.max.asArray()}if(s.hasTangents){const t=i.getVerticesData(h.VertexBuffer.TangentKind,void 0,void 0,!0),a=s.getTangents(),o=e.verticesCount,l=12,c=o*l,u=p._CreateBufferView(0,r.getByteOffset(),c,l,s.name+"_NORMAL");this._bufferViews.push(u);const f=this._bufferViews.length-1,d=p._CreateAccessor(f,s.name+" - TANGENT","VEC3",5126,o,0,null,null);this._accessors.push(d),n.TANGENT=this._accessors.length-1,this.writeMorphTargetAttributeData(h.VertexBuffer.TangentKind,5126,e,t,a,l/4,r)}t.targets.push(n)}}_getMeshPrimitiveMode(e){if(e instanceof h.LinesMesh)return h.Material.LineListDrawMode;if(e instanceof h.InstancedMesh||e instanceof h.Mesh){const t=e instanceof h.Mesh?e:e.sourceMesh;if("number"==typeof t.overrideRenderingFillMode)return t.overrideRenderingFillMode}return e.material?e.material.fillMode:h.Material.TriangleFillMode}_setPrimitiveMode(e,t){switch(t){case h.Material.TriangleFillMode:break;case h.Material.TriangleStripDrawMode:e.mode=5;break;case h.Material.TriangleFanDrawMode:e.mode=6;break;case h.Material.PointListDrawMode:case h.Material.PointFillMode:e.mode=0;break;case h.Material.LineLoopDrawMode:e.mode=2;break;case h.Material.LineListDrawMode:e.mode=1;break;case h.Material.LineStripDrawMode:e.mode=3}}_setAttributeKind(e,t){switch(t){case h.VertexBuffer.PositionKind:e.attributes.POSITION=this._accessors.length-1;break;case h.VertexBuffer.NormalKind:e.attributes.NORMAL=this._accessors.length-1;break;case h.VertexBuffer.ColorKind:e.attributes.COLOR_0=this._accessors.length-1;break;case h.VertexBuffer.TangentKind:e.attributes.TANGENT=this._accessors.length-1;break;case h.VertexBuffer.UVKind:e.attributes.TEXCOORD_0=this._accessors.length-1;break;case h.VertexBuffer.UV2Kind:e.attributes.TEXCOORD_1=this._accessors.length-1;break;case h.VertexBuffer.MatricesIndicesKind:e.attributes.JOINTS_0=this._accessors.length-1;break;case h.VertexBuffer.MatricesIndicesExtraKind:e.attributes.JOINTS_1=this._accessors.length-1;break;case h.VertexBuffer.MatricesWeightsKind:e.attributes.WEIGHTS_0=this._accessors.length-1;break;case h.VertexBuffer.MatricesWeightsExtraKind:e.attributes.WEIGHTS_1=this._accessors.length-1;break;default:h.Tools.Warn("Unsupported Vertex Buffer Type: "+t)}}_setPrimitiveAttributesAsync(e,t,s){const r=[];let n,i,a=null;t instanceof h.Mesh?a=t:t instanceof h.InstancedMesh&&(a=t.sourceMesh);const o=[{kind:h.VertexBuffer.PositionKind,accessorType:"VEC3",accessorComponentType:5126,byteStride:12},{kind:h.VertexBuffer.NormalKind,accessorType:"VEC3",accessorComponentType:5126,byteStride:12},{kind:h.VertexBuffer.ColorKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16},{kind:h.VertexBuffer.TangentKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16},{kind:h.VertexBuffer.UVKind,accessorType:"VEC2",accessorComponentType:5126,byteStride:8},{kind:h.VertexBuffer.UV2Kind,accessorType:"VEC2",accessorComponentType:5126,byteStride:8},{kind:h.VertexBuffer.MatricesIndicesKind,accessorType:"VEC4",accessorComponentType:5123,byteStride:8},{kind:h.VertexBuffer.MatricesIndicesExtraKind,accessorType:"VEC4",accessorComponentType:5123,byteStride:8},{kind:h.VertexBuffer.MatricesWeightsKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16},{kind:h.VertexBuffer.MatricesWeightsExtraKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16}];if(a){let l=null;const c=this._getMeshPrimitiveMode(a),u={},f=a.morphTargetManager;for(const e of o){const r=e.kind,n=e.accessorComponentType;if(a.isVerticesDataPresent(r,!0)){const i=this._getVertexBufferFromMesh(r,a);e.byteStride=i?i.getSize()*h.VertexBuffer.GetTypeByteLength(e.accessorComponentType):4*h.VertexBuffer.DeduceStride(r),12===e.byteStride&&(e.accessorType="VEC3"),this._createBufferViewKind(r,n,t,s,e.byteStride),e.bufferViewIndex=this._bufferViews.length-1,u[r]=e.bufferViewIndex}}if(a.getTotalIndices()){const e=a.getIndices();if(e){const t=4*e.length;n=p._CreateBufferView(0,s.getByteOffset(),t,void 0,"Indices - "+a.name),this._bufferViews.push(n),l=this._bufferViews.length-1;for(let t=0,r=e.length;t<r;++t)s.setUInt32(e[t])}}if(a.subMeshes)for(const n of a.subMeshes){let d=n.getMaterial()||a.getScene().defaultMaterial,_=null;if(d)if(a instanceof h.LinesMesh){const e={name:a.name+" material"};(!a.color.equals(h.Color3.White())||a.alpha<1)&&(e.pbrMetallicRoughness={baseColorFactor:a.color.asArray().concat([a.alpha])}),this._materials.push(e),_=this._materials.length-1}else if(d instanceof h.MultiMaterial){const e=d.subMaterials[n.materialIndex];e&&(d=e,_=this._materialMap[d.uniqueId])}else _=this._materialMap[d.uniqueId];const m=null!=_?this._materials[_]:null,g={attributes:{}};this._setPrimitiveMode(g,c);for(const e of o){const s=e.kind;if(!(s!==h.VertexBuffer.UVKind&&s!==h.VertexBuffer.UV2Kind||this._options.exportUnusedUVs||m&&this._glTFMaterialExporter._hasTexturesPresent(m)))continue;const r=a.getVerticesData(s,void 0,void 0,!0);if(r){const n=this._getVertexBufferFromMesh(s,a);if(n){const a=n.getSize(),o=e.bufferViewIndex;if(null!=o){i={min:null,max:null},s==h.VertexBuffer.PositionKind&&(i=p._CalculateMinMaxPositions(r,0,r.length/a));const n=p._CreateAccessor(o,s+" - "+t.name,e.accessorType,e.accessorComponentType,r.length/a,0,i.min,i.max);this._accessors.push(n),this._setAttributeKind(g,s)}}}}if(l){const e=p._CreateAccessor(l,"indices - "+t.name,"SCALAR",5125,n.indexCount,4*n.indexStart,null,null);this._accessors.push(e),g.indices=this._accessors.length-1}if(null!=_&&Object.keys(g.attributes).length>0){if((null!==a.overrideMaterialSideOrientation?a.overrideMaterialSideOrientation:d.sideOrientation)===(this._babylonScene.useRightHandedSystem?h.Material.ClockWiseSideOrientation:h.Material.CounterClockWiseSideOrientation)){let e=null!=l?this._bufferViews[l].byteOffset:null;null==e&&(e=0);let t=null;if(null!=l&&(t=a.getIndices()),t)this._reorderIndicesBasedOnPrimitiveMode(n,c,t,e,s);else for(const e of o){const t=a.getVerticesData(e.kind,void 0,void 0,!0);if(t){const r=this._bufferViews[u[e.kind]].byteOffset||0;this._reorderVertexAttributeDataBasedOnPrimitiveMode(n,c,e.kind,t,r,s)}}}g.material=_}if(f){let e;for(let t=0;t<f.numTargets;++t)e=f.getTarget(t),this._setMorphTargetAttributes(n,g,e,s)}e.primitives.push(g),this._extensionsPostExportMeshPrimitiveAsync("postExport",g,n,s),r.push()}}return Promise.all(r).then((()=>{}))}_createSceneAsync(e){const t={nodes:[]};let s,r,n;const i=[...this._babylonScene.transformNodes,...this._babylonScene.meshes,...this._babylonScene.lights,...this._babylonScene.cameras],a=new Set;if(this._babylonScene.metadata&&(this._options.metadataSelector?t.extras=this._options.metadataSelector(this._babylonScene.metadata):this._babylonScene.metadata.gltf&&(t.extras=this._babylonScene.metadata.gltf.extras)),(this._options.removeNoopRootNodes??1)&&!this._options.includeCoordinateSystemConversionNodes)for(const e of this._babylonScene.rootNodes)m(e,this._babylonScene.useRightHandedSystem)&&(a.add(e),i.splice(i.indexOf(e),1));const o=new Map;this._babylonScene.cameras.forEach((e=>{if(!this._options.shouldExportNode||this._options.shouldExportNode(e)){const t={type:e.mode===h.Camera.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(e.name&&(t.name=e.name),"perspective"===t.type)t.perspective={aspectRatio:e.getEngine().getAspectRatio(e),yfov:e.fovMode===h.Camera.FOVMODE_VERTICAL_FIXED?e.fov:e.fov*e.getEngine().getAspectRatio(e),znear:e.minZ,zfar:e.maxZ};else if("orthographic"===t.type){const s=e.orthoLeft&&e.orthoRight?.5*(e.orthoRight-e.orthoLeft):.5*e.getEngine().getRenderWidth(),r=e.orthoBottom&&e.orthoTop?.5*(e.orthoTop-e.orthoBottom):.5*e.getEngine().getRenderHeight();t.orthographic={xmag:s,ymag:r,znear:e.minZ,zfar:e.maxZ}}o.set(e,this._cameras.length),this._cameras.push(t)}}));const[l,c]=this._getExportNodes(i);return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(c,"image/png",!0).then((()=>this._createNodeMapAndAnimationsAsync(l,e).then((l=>this._createSkinsAsync(l,e).then((c=>{if(this._nodeMap=l,this._totalByteLength=e.getByteOffset(),null==this._totalByteLength)throw new Error("undefined byte length!");for(const e of i)if(s=this._nodeMap[e.uniqueId],void 0!==s&&(r=this._nodes[s],e.metadata&&(this._options.metadataSelector?r.extras=this._options.metadataSelector(e.metadata):e.metadata.gltf&&(r.extras=e.metadata.gltf.extras)),e instanceof h.Camera&&(r.camera=o.get(e)),this._options.shouldExportNode&&!this._options.shouldExportNode(e)?h.Tools.Log("Omitting "+e.name+" from scene."):(e.parent||this._babylonScene.useRightHandedSystem||g(r),e.parent&&!a.has(e.parent)||t.nodes.push(s)),e instanceof h.Mesh&&e.skeleton&&(r.skin=c[e.skeleton.uniqueId]),n=e.getDescendants(!0),!r.children&&n&&n.length)){const e=[];for(const t of n)null!=this._nodeMap[t.uniqueId]&&e.push(this._nodeMap[t.uniqueId]);e.length&&(r.children=e)}t.nodes.length&&this._scenes.push(t)}))))))}_getExportNodes(e){const t=[],s=new Set;for(const r of e)if(!this._options.shouldExportNode||this._options.shouldExportNode(r)){t.push(r);const e=r;if(e.subMeshes&&e.subMeshes.length>0){const t=e.material||e.getScene().defaultMaterial;if(t instanceof h.MultiMaterial)for(const e of t.subMaterials)e&&s.add(e);else s.add(t)}}else r.name;return[t,s]}_createNodeMapAndAnimationsAsync(e,t){let s=Promise.resolve();const r={};let n;const i={name:"runtime animations",channels:[],samplers:[]},a=[];for(const o of e)s=s.then((()=>this._createNodeAsync(o,t).then((e=>{const s=this._extensionsPostExportNodeAsync("createNodeAsync",e,o,r,t);return null==s?(h.Tools.Warn(`Not exporting node ${o.name}`),Promise.resolve()):s.then((e=>{e&&(this._nodes.push(e),n=this._nodes.length-1,r[o.uniqueId]=n,this._babylonScene.animationGroups.length||(d._CreateMorphTargetAnimationFromMorphTargetAnimations(o,i,a,r,this._nodes,t,this._bufferViews,this._accessors,this._animationSampleRate,this._options.shouldExportAnimation),o.animations.length&&d._CreateNodeAnimationFromNodeAnimations(o,i,a,r,this._nodes,t,this._bufferViews,this._accessors,this._animationSampleRate,this._options.shouldExportAnimation)))}))}))));return s.then((()=>(i.channels.length&&i.samplers.length&&this._animations.push(i),a.forEach((e=>{e.channels.length&&e.samplers.length&&this._animations.push(e)})),this._babylonScene.animationGroups.length&&d._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,r,t,this._bufferViews,this._accessors,this._animationSampleRate,this._options.shouldExportAnimation),r)))}_createNodeAsync(e,t){return Promise.resolve().then((()=>{const s={},r={primitives:[]};if(e.name&&(s.name=e.name),e instanceof h.TransformNode){if(this._setNodeTransformation(s,e),e instanceof h.Mesh){const t=e.morphTargetManager;if(t&&t.numTargets>0){r.weights=[];for(let e=0;e<t.numTargets;++e)r.weights.push(t.getTarget(e).influence)}}return this._setPrimitiveAttributesAsync(r,e,t).then((()=>(r.primitives.length&&(this._meshes.push(r),s.mesh=this._meshes.length-1),s)))}return e instanceof h.Camera?(this._setCameraTransformation(s,e),s):s}))}_createSkinsAsync(e,t){const s=Promise.resolve(),r={};for(const s of this._babylonScene.skeletons){if(s.bones.length<=0)continue;const n={joints:[]},i=[],a={};let o=-1;for(let e=0;e<s.bones.length;++e){const t=s.bones[e],r=t.getIndex()??e;-1!==r&&(a[r]=t,r>o&&(o=r))}for(let t=0;t<=o;++t){const s=a[t];i.push(s.getInvertedAbsoluteTransform());const r=s.getTransformNode();r&&null!==e[r.uniqueId]&&void 0!==e[r.uniqueId]?n.joints.push(e[r.uniqueId]):h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}if(n.joints.length>0){const e=64,a=i.length*e,o=t.getByteOffset(),l=p._CreateBufferView(0,o,a,void 0,"InverseBindMatrices - "+s.name);this._bufferViews.push(l);const c=this._bufferViews.length-1,u=p._CreateAccessor(c,"InverseBindMatrices - "+s.name,"MAT4",5126,i.length,null,null,null),h=this._accessors.push(u)-1;n.inverseBindMatrices=h,this._skins.push(n),r[s.uniqueId]=this._skins.length-1,i.forEach((e=>{e.m.forEach((e=>{t.setFloat32(e)}))}))}}return s.then((()=>r))}}x._ExtensionNames=new Array,x._ExtensionFactories={};class T{constructor(e){this._arrayBuffer=new ArrayBuffer(e),this._dataView=new DataView(this._arrayBuffer),this._byteOffset=0}_resizeBuffer(e){const t=new ArrayBuffer(e),s=Math.min(this._arrayBuffer.byteLength,e),r=new Uint8Array(this._arrayBuffer,0,s);return new Uint8Array(t).set(r,0),this._arrayBuffer=t,this._dataView=new DataView(this._arrayBuffer),t}getArrayBuffer(){return this._resizeBuffer(this.getByteOffset())}getByteOffset(){if(null==this._byteOffset)throw new Error("Byte offset is undefined!");return this._byteOffset}setUInt8(e,t){null!=t?t<this._byteOffset?this._dataView.setUint8(t,e):h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+1>this._arrayBuffer.byteLength&&this._resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint8(this._byteOffset,e),this._byteOffset+=1)}setUInt16(e,t){null!=t?t<this._byteOffset?this._dataView.setUint16(t,e,!0):h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+2>this._arrayBuffer.byteLength&&this._resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint16(this._byteOffset,e,!0),this._byteOffset+=2)}getUInt32(e){if(e<this._byteOffset)return this._dataView.getUint32(e,!0);throw h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"),new Error("BinaryWriter: byteoffset is greater than the current binary buffer length!")}getVector3Float32FromRef(e,t){t+8>this._byteOffset?h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(e.x=this._dataView.getFloat32(t,!0),e.y=this._dataView.getFloat32(t+4,!0),e.z=this._dataView.getFloat32(t+8,!0))}setVector3Float32FromRef(e,t){t+8>this._byteOffset?h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._dataView.setFloat32(t,e.x,!0),this._dataView.setFloat32(t+4,e.y,!0),this._dataView.setFloat32(t+8,e.z,!0))}getVector4Float32FromRef(e,t){t+12>this._byteOffset?h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(e.x=this._dataView.getFloat32(t,!0),e.y=this._dataView.getFloat32(t+4,!0),e.z=this._dataView.getFloat32(t+8,!0),e.w=this._dataView.getFloat32(t+12,!0))}setVector4Float32FromRef(e,t){t+12>this._byteOffset?h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._dataView.setFloat32(t,e.x,!0),this._dataView.setFloat32(t+4,e.y,!0),this._dataView.setFloat32(t+8,e.z,!0),this._dataView.setFloat32(t+12,e.w,!0))}setFloat32(e,t){isNaN(e)&&h.Tools.Error("Invalid data being written!"),null!=t&&(t<this._byteOffset?this._dataView.setFloat32(t,e,!0):h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary length!")),this._byteOffset+4>this._arrayBuffer.byteLength&&this._resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setFloat32(this._byteOffset,e,!0),this._byteOffset+=4}setUInt32(e,t){null!=t?t<this._byteOffset?this._dataView.setUint32(t,e,!0):h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+4>this._arrayBuffer.byteLength&&this._resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint32(this._byteOffset,e,!0),this._byteOffset+=4)}setInt16(e,t){null!=t?t<this._byteOffset?this._dataView.setInt16(t,e,!0):h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+2>this._arrayBuffer.byteLength&&this._resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setInt16(this._byteOffset,e,!0),this._byteOffset+=2)}setByte(e,t){null!=t?t<this._byteOffset?this._dataView.setInt8(t,e):h.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+1>this._arrayBuffer.byteLength&&this._resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setInt8(this._byteOffset,e),this._byteOffset++)}}class y{static GLTFAsync(e,t,s){return e.whenReadyAsync().then((()=>{const r=t.replace(/\.[^/.]+$/,"");return new x(e,s)._generateGLTFAsync(r)}))}static _PreExportAsync(e,t){return Promise.resolve().then((()=>t&&t.exportWithoutWaitingForScene?Promise.resolve():e.whenReadyAsync()))}static _PostExportAsync(e,t,s){return Promise.resolve().then((()=>(s&&s.exportWithoutWaitingForScene,t)))}static GLBAsync(e,t,s){return this._PreExportAsync(e,s).then((()=>{const r=t.replace(/\.[^/.]+$/,"");return new x(e,s)._generateGLBAsync(r).then((t=>this._PostExportAsync(e,t,s)))}))}}const b="KHR_texture_transform";class A{constructor(){this.name=b,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(e,t,s){if(s&&(0===s.uAng&&0===s.wAng&&0===s.vAng||0===s.uRotationCenter&&0===s.vRotationCenter)){const e={};let r=!1;if(0===s.uOffset&&0===s.vOffset||(e.offset=[s.uOffset,s.vOffset],r=!0),1===s.uScale&&1===s.vScale||(e.scale=[s.uScale,s.vScale],r=!0),0!==s.wAng&&(e.rotation=-s.wAng,r=!0),0!==s.coordinatesIndex&&(e.texCoord=s.coordinatesIndex,r=!0),!r)return;this._wasUsed=!0,t.extensions||(t.extensions={}),t.extensions[b]=e}}preExportTextureAsync(e,t){return new Promise(((s,r)=>{t.getScene()?0!==t.uAng||0!==t.vAng?(h.Tools.Warn(`${e}: Texture ${t.name} with rotation in the u or v axis is not supported in glTF.`),s(null)):0===t.wAng||0===t.uRotationCenter&&0===t.vRotationCenter?s(t):(h.Tools.Warn(`${e}: Texture ${t.name} with rotation not centered at the origin cannot be exported with ${b}`),s(null)):r(`${e}: "scene" is not defined for Babylon texture ${t.name}!`)}))}}x.RegisterExtension(b,(()=>new A));const E="KHR_lights_punctual";class M{constructor(e){this.name=E,this.enabled=!0,this.required=!1,this._exporter=e}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[E]=this._lights}postExportNodeAsync(e,t,s,r){return new Promise((n=>{if(t&&s instanceof h.ShadowLight){let i;const a=s.getTypeID()==h.Light.LIGHTTYPEID_POINTLIGHT?"point":s.getTypeID()==h.Light.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":s.getTypeID()==h.Light.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(null==a)h.Logger.Warn(`${e}: Light ${s.name} is not supported in ${E}`);else{if(s.position.equalsToFloats(0,0,0)||(t.translation=s.position.asArray()),"point"!==a){const e=s.direction,r=-Math.atan2(e.z,e.x)+Math.PI/2,n=Math.sqrt(e.x*e.x+e.z*e.z),i=-Math.atan2(e.y,n),a=h.Quaternion.RotationYawPitchRoll(r+Math.PI,i,0);h.Quaternion.IsIdentity(a)||(t.rotation=a.asArray())}if(s.falloffType!==h.Light.FALLOFF_GLTF&&h.Logger.Warn(`${e}: Light falloff for ${s.name} does not match the ${E} specification!`),i={type:a},s.diffuse.equals(h.Color3.White())||(i.color=s.diffuse.asArray()),1!==s.intensity&&(i.intensity=s.intensity),s.range!==Number.MAX_VALUE&&(i.range=s.range),"spot"===a){const e=s;e.angle!==Math.PI/2&&(null==i.spot&&(i.spot={}),i.spot.outerConeAngle=e.angle/2),0!==e.innerAngle&&(null==i.spot&&(i.spot={}),i.spot.innerConeAngle=e.innerAngle/2)}this._lights||={lights:[]},this._lights.lights.push(i);const o={light:this._lights.lights.length-1},l=s.parent;if(l&&1==l.getChildren().length){const e=this._exporter._nodes[r[l.uniqueId]];if(e){const s=h.Vector3.FromArrayToRef(e.translation||[0,0,0],0,h.TmpVectors.Vector3[0]),r=h.Quaternion.FromArrayToRef(e.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[0]),i=h.Vector3.FromArrayToRef(e.scale||[1,1,1],0,h.TmpVectors.Vector3[1]),a=h.Matrix.ComposeToRef(i,r,s,h.TmpVectors.Matrix[0]),l=h.Vector3.FromArrayToRef(t.translation||[0,0,0],0,h.TmpVectors.Vector3[2]),c=h.Quaternion.FromArrayToRef(t.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[1]),u=h.Matrix.ComposeToRef(h.Vector3.OneReadOnly,c,l,h.TmpVectors.Matrix[1]);return a.multiplyToRef(u,u),u.decompose(i,r,s),s.equalsToFloats(0,0,0)?delete e.translation:e.translation=s.asArray(),h.Quaternion.IsIdentity(r)?delete e.rotation:e.rotation=r.asArray(),i.equalsToFloats(1,1,1)?delete e.scale:e.scale=i.asArray(),e.extensions||={},e.extensions[E]=o,void n(null)}}t.extensions||={},t.extensions[E]=o}}n(t)}))}}x.RegisterExtension(E,(e=>new M(e)));const F="KHR_materials_clearcoat";class w{constructor(e){this.name=F,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){const r=[];return s instanceof h.PBRBaseMaterial&&s.clearCoat.isEnabled?(s.clearCoat.texture&&r.push(s.clearCoat.texture),!s.clearCoat.useRoughnessFromMainTexture&&s.clearCoat.textureRoughness&&r.push(s.clearCoat.textureRoughness),s.clearCoat.bumpTexture&&r.push(s.clearCoat.bumpTexture),r):[]}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRBaseMaterial){if(!s.clearCoat.isEnabled)return void e(t);this._wasUsed=!0,t.extensions=t.extensions||{};const r=this._exporter._glTFMaterialExporter._getTextureInfo(s.clearCoat.texture);let n;n=s.clearCoat.useRoughnessFromMainTexture?this._exporter._glTFMaterialExporter._getTextureInfo(s.clearCoat.texture):this._exporter._glTFMaterialExporter._getTextureInfo(s.clearCoat.textureRoughness),s.clearCoat.isTintEnabled&&h.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${s.name}`),s.clearCoat.remapF0OnInterfaceChange&&h.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${s.name}`);const i=this._exporter._glTFMaterialExporter._getTextureInfo(s.clearCoat.bumpTexture),a={clearcoatFactor:s.clearCoat.intensity,clearcoatTexture:r??void 0,clearcoatRoughnessFactor:s.clearCoat.roughness,clearcoatRoughnessTexture:n??void 0,clearcoatNormalTexture:i??void 0,hasTextures:()=>null!==a.clearcoatTexture||null!==a.clearcoatRoughnessTexture||null!==a.clearcoatRoughnessTexture};t.extensions[F]=a}e(t)}))}}x.RegisterExtension(F,(e=>new w(e)));const C="KHR_materials_iridescence";class V{constructor(e){this.name=C,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){const r=[];return s instanceof h.PBRBaseMaterial&&s.iridescence.isEnabled?(s.iridescence.texture&&r.push(s.iridescence.texture),s.iridescence.thicknessTexture&&s.iridescence.thicknessTexture!==s.iridescence.texture&&r.push(s.iridescence.thicknessTexture),r):[]}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRBaseMaterial){if(!s.iridescence.isEnabled)return void e(t);this._wasUsed=!0,t.extensions=t.extensions||{};const r=this._exporter._glTFMaterialExporter._getTextureInfo(s.iridescence.texture),n=this._exporter._glTFMaterialExporter._getTextureInfo(s.iridescence.thicknessTexture),i={iridescenceFactor:s.iridescence.intensity,iridescenceIor:s.iridescence.indexOfRefraction,iridescenceThicknessMinimum:s.iridescence.minimumThickness,iridescenceThicknessMaximum:s.iridescence.maximumThickness,iridescenceTexture:r??void 0,iridescenceThicknessTexture:n??void 0,hasTextures:()=>null!==i.iridescenceTexture||null!==i.iridescenceThicknessTexture};t.extensions[C]=i}e(t)}))}}x.RegisterExtension(C,(e=>new V(e)));const R="KHR_materials_anisotropy";class S{constructor(e){this.name=R,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){const r=[];return s instanceof h.PBRBaseMaterial&&s.anisotropy.isEnabled&&!s.anisotropy.legacy?(s.anisotropy.texture&&r.push(s.anisotropy.texture),r):[]}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRBaseMaterial){if(!s.anisotropy.isEnabled||s.anisotropy.legacy)return void e(t);this._wasUsed=!0,t.extensions=t.extensions||{};const r=this._exporter._glTFMaterialExporter._getTextureInfo(s.anisotropy.texture),n={anisotropyStrength:s.anisotropy.intensity,anisotropyRotation:s.anisotropy.angle,anisotropyTexture:r??void 0,hasTextures:()=>null!==n.anisotropyTexture};t.extensions[R]=n}e(t)}))}}x.RegisterExtension(R,(e=>new S(e)));const I="KHR_materials_sheen";class v{constructor(e){this.name=I,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){return s instanceof h.PBRMaterial&&s.sheen.isEnabled&&s.sheen.texture?[s.sheen.texture]:[]}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRMaterial){if(!s.sheen.isEnabled)return void e(t);this._wasUsed=!0,null==t.extensions&&(t.extensions={});const r={sheenColorFactor:s.sheen.color.asArray(),sheenRoughnessFactor:s.sheen.roughness??0,hasTextures:()=>null!==r.sheenColorTexture||null!==r.sheenRoughnessTexture};s.sheen.texture&&(r.sheenColorTexture=this._exporter._glTFMaterialExporter._getTextureInfo(s.sheen.texture)??void 0),s.sheen.textureRoughness&&!s.sheen.useRoughnessFromMainTexture?r.sheenRoughnessTexture=this._exporter._glTFMaterialExporter._getTextureInfo(s.sheen.textureRoughness)??void 0:s.sheen.texture&&s.sheen.useRoughnessFromMainTexture&&(r.sheenRoughnessTexture=this._exporter._glTFMaterialExporter._getTextureInfo(s.sheen.texture)??void 0),t.extensions[I]=r}e(t)}))}}x.RegisterExtension(I,(e=>new v(e)));const B="KHR_materials_unlit";class P{constructor(){this.name=B,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(e,t,s){return new Promise((e=>{let r=!1;s instanceof h.PBRMaterial?r=s.unlit:s instanceof h.StandardMaterial&&(r=s.disableLighting),r&&(this._wasUsed=!0,null==t.extensions&&(t.extensions={}),t.extensions[B]={}),e(t)}))}}x.RegisterExtension(B,(()=>new P));const N="KHR_materials_ior";class L{constructor(){this.name=N,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(e){return!e.unlit&&null!=e.indexOfRefraction&&1.5!=e.indexOfRefraction}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)){this._wasUsed=!0;const e={ior:s.indexOfRefraction};t.extensions=t.extensions||{},t.extensions[N]=e}e(t)}))}}x.RegisterExtension(N,(e=>new L));const O="KHR_materials_specular";class U{constructor(e){this.name=O,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){const r=[];return s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)?(s.metallicReflectanceTexture&&r.push(s.metallicReflectanceTexture),s.reflectanceTexture&&r.push(s.reflectanceTexture),r):r}_isExtensionEnabled(e){return!e.unlit&&(null!=e.metallicF0Factor&&1!=e.metallicF0Factor||null!=e.metallicReflectanceColor&&!e.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(e))}_hasTexturesExtension(e){return null!=e.metallicReflectanceTexture||null!=e.reflectanceTexture}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)){this._wasUsed=!0,t.extensions=t.extensions||{};const e=this._exporter._glTFMaterialExporter._getTextureInfo(s.metallicReflectanceTexture)??void 0,r=this._exporter._glTFMaterialExporter._getTextureInfo(s.reflectanceTexture)??void 0,n={specularFactor:1==s.metallicF0Factor?void 0:s.metallicF0Factor,specularTexture:e,specularColorFactor:s.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:s.metallicReflectanceColor.asArray(),specularColorTexture:r,hasTextures:()=>this._hasTexturesExtension(s)};t.extensions[O]=n}e(t)}))}}x.RegisterExtension(O,(e=>new U(e)));const k="KHR_materials_volume";class K{constructor(e){this.name=k,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){const r=[];return s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)?(s.subSurface.thicknessTexture&&r.push(s.subSurface.thicknessTexture),r):r}_isExtensionEnabled(e){if(e.unlit)return!1;const t=e.subSurface;return!(!t.isRefractionEnabled&&!t.isTranslucencyEnabled)&&(null!=t.maximumThickness&&0!=t.maximumThickness||null!=t.tintColorAtDistance&&t.tintColorAtDistance!=Number.POSITIVE_INFINITY||null!=t.tintColor&&t.tintColor!=h.Color3.White()||this._hasTexturesExtension(e))}_hasTexturesExtension(e){return null!=e.subSurface.thicknessTexture}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)){this._wasUsed=!0;const e=s.subSurface,r={thicknessFactor:0==e.maximumThickness?void 0:e.maximumThickness,thicknessTexture:this._exporter._glTFMaterialExporter._getTextureInfo(e.thicknessTexture)??void 0,attenuationDistance:e.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:e.tintColorAtDistance,attenuationColor:e.tintColor.equalsFloats(1,1,1)?void 0:e.tintColor.asArray(),hasTextures:()=>this._hasTexturesExtension(s)};t.extensions=t.extensions||{},t.extensions[k]=r}e(t)}))}}x.RegisterExtension(k,(e=>new K(e)));const D="KHR_materials_transmission";class G{constructor(e){this.name=D,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,s){const r=[];return s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)?(s.subSurface.thicknessTexture&&r.push(s.subSurface.thicknessTexture),r):r}_isExtensionEnabled(e){if(e.unlit)return!1;const t=e.subSurface;return t.isRefractionEnabled&&null!=t.refractionIntensity&&0!=t.refractionIntensity||this._hasTexturesExtension(e)}_hasTexturesExtension(e){return null!=e.subSurface.refractionIntensityTexture}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(s instanceof h.PBRMaterial&&this._isExtensionEnabled(s)){this._wasUsed=!0;const e=s.subSurface,r={transmissionFactor:0===e.refractionIntensity?void 0:e.refractionIntensity,transmissionTexture:this._exporter._glTFMaterialExporter._getTextureInfo(e.refractionIntensityTexture)??void 0,hasTextures:()=>this._hasTexturesExtension(s)};t.extensions=t.extensions||{},t.extensions[D]=r}e(t)}))}}x.RegisterExtension(D,(e=>new G(e)));const W="EXT_mesh_gpu_instancing";class z{constructor(e){this.name=W,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportNodeAsync(e,t,s,r,n){return new Promise((e=>{if(t&&s instanceof h.Mesh&&s.hasThinInstances&&n){this._wasUsed=!0;const e=h.Vector3.Zero(),r=h.Quaternion.Identity(),i=h.Vector3.One(),a=s.thinInstanceGetWorldMatrices(),o=h.TmpVectors.Vector3[2],l=h.TmpVectors.Quaternion[1],c=h.TmpVectors.Vector3[3];let u=!1,f=!1,p=!1;const d=new Float32Array(3*s.thinInstanceCount),_=new Float32Array(4*s.thinInstanceCount),m=new Float32Array(3*s.thinInstanceCount);let g=0;for(const t of a)t.decompose(c,l,o),d.set(o.asArray(),3*g),_.set(l.normalize().asArray(),4*g),m.set(c.asArray(),3*g),u=u||!o.equalsWithEpsilon(e),f=f||!l.equalsWithEpsilon(r),p=p||!c.equalsWithEpsilon(i),g++;const x={attributes:{}};if(u&&(x.attributes.TRANSLATION=this._buildAccessor(d,"VEC3",s.thinInstanceCount,n,5126)),f){const e=5126;x.attributes.ROTATION=this._buildAccessor(_,"VEC4",s.thinInstanceCount,n,e)}p&&(x.attributes.SCALE=this._buildAccessor(m,"VEC3",s.thinInstanceCount,n,5126)),t.extensions=t.extensions||{},t.extensions[W]=x}e(t)}))}_buildAccessor(e,t,s,r,n){const i=r.getByteOffset();switch(n){case 5126:for(let t=0;t!=e.length;t++)r.setFloat32(e[t]);break;case 5120:for(let t=0;t!=e.length;t++)r.setByte(127*e[t]);break;case 5122:for(let t=0;t!=e.length;t++)r.setInt16(32767*e[t])}const a={buffer:0,byteOffset:i,byteLength:e.length*h.VertexBuffer.GetTypeByteLength(n)},o=this._exporter._bufferViews.length;this._exporter._bufferViews.push(a);const l=this._exporter._accessors.length,c={bufferView:o,componentType:n,count:s,type:t,normalized:5120==n||5122==n};return this._exporter._accessors.push(c),l}}x.RegisterExtension(W,(e=>new z(e)));const q="KHR_materials_emissive_strength";class H{constructor(){this.name=q,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAsync(e,t,s){return new Promise((e=>{if(!(s instanceof h.PBRMaterial))return e(t);const r=s.emissiveColor.asArray(),n=Math.max(...r);if(n>1){this._wasUsed=!0,t.extensions||={};const e={emissiveStrength:n},r=s.emissiveColor.scale(1/e.emissiveStrength);t.emissiveFactor=r.asArray(),t.extensions[q]=e}return e(t)}))}}x.RegisterExtension(q,(e=>new H));var $=0;const Q=void 0!==r.g?r.g:"undefined"!=typeof window?window:void 0;if(void 0!==Q){Q.BABYLON=Q.BABYLON||{};const r=Q.BABYLON;r.GLTF2=r.GLTF2||{},r.GLTF2.Exporter=r.GLTF2.Exporter||{},r.GLTF2.Exporter.Extensions=r.GLTF2.Exporter.Extensions||{};const n=[];for(const t in e)r[t]=e[t],n.push(t);for(const e in t)r[e]=t[e],n.push(e);for(const e in s)r[e]=s[e],n.push(e);for(const e in i)r.GLTF2.Exporter.Extensions[e]=i[e],n.push(e);for(const e in a)n.indexOf(e)>-1||(r.GLTF2.Exporter[e]=a[e])}const j=o})(),n.default})()));
//# sourceMappingURL=babylon.glTF2Serializer.min.js.map